/*
 * Copyright (C) Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
define(['dojo/_base/connect', 'dojo/_base/declare', 'light/utils/URLUtils',
        'dojo', 'light/enums/SearchEventsEnum', 'light/RegexCommon'],
        function(connect, declare, URLUtils, dojo,
                 SearchEventsEnum, RegexCommon) {

  /** @exports SearchRouter as light.SearchRouter */
  var SearchRouter = declare('light.SearchRouter', null, {
    /** @lends light.SearchRouter# */

    /**
     * Responsible for syncing the URL hash with the current search state.
     *
     * @constructs
     */
    constructor: function() {

      /**
       * Last sucessful query state.
       *
       * It is initialized with the default "empty" one
       */
      this._lastSearchState = this.DEFAULT_SEARCH_STATE;

      /**
       * Auxiliary variable to help skip handling hash
       * changes caused by this router.
       */
      this._skipHash = null;
    },

    /**
     * Default query state (empty, no query)
     *
     * @const
     */
    DEFAULT_SEARCH_STATE: {
      page: 1,
      query: ''
    },

    /**
     * Wire's this object to the dojo event system so it can
     * watch for search state changes and or changes in
     * the hash (http://www.../somepage#SOMEHASH) to
     * change the search state based on it.
     */
    watch: function() {
      connect.subscribe('/dojo/hashchange', this, this._onHashChange);
      connect.subscribe(SearchEventsEnum.SEARCH_STATE_CHANGED, this,
              this._onSearchStateChange);
      this._onHashChange(URLUtils.getHash());
    },

    /**
     * Set's the hash taking care of avoiding this router
     * to handle this hashChange.
     */
    _setHash: function(hash, replaceCurrentInHistory) {
      this._skipHash = hash;
      URLUtils.setHash(hash, replaceCurrentInHistory);
    },

    /**
     * Checks if we should skip handling this hash change.
     *
     * <p>This is particularly useful to avoid this router
     * to handle hashChanges caused by itself.
     */
    _shouldSkipThisHashChange: function(hash) {
      var result = this._skipHash == hash;
      this._skipHash = null;
      return result;
    },

    /**
     * Handles searchStateChange events.
     */
    _onSearchStateChange: function(searchState, source) {
      if (source != this) {
        this._lastSearchState = searchState;
        this._setHash(SearchRouter.searchStateToHash(searchState));
      }
    },

    /**
     * Callback that should be called every time the hash changes to
     * update the search state based on the new hash.
     *
     * If the hash is not well formated, it will use the last
     * valid search state or the default one.
     * @param {String} hash The current page hash.
     * @private
     */
    _onHashChange: function(hash) {
      if (this._shouldSkipThisHashChange(hash))
        return;
      var searchState = null;
      try {
        searchState = SearchRouter.hashToSearchState(hash);
      } catch (e) {
        // TODO(waltercacau): Warn the user that his query was wrong
      }
      if (searchState) {
        this._lastSearchState = searchState;
        connect.publish(SearchEventsEnum.SEARCH_STATE_CHANGED,
                [searchState, this]);
      } else {
        this._setHash(SearchRouter.searchStateToHash(this._lastSearchState),
                      true
                      /* replaces the current wrong one in browser history */);
      }
    }
  });

  /**
   * Serializes a SearchState object into a string to be used
   * as hashtag in the URL.
   *
   * @param {Object} data The SearchState object.
   * @return {string} Serialized search state.
   */
  SearchRouter.searchStateToHash = function(data) {
    return dojo.objectToQuery(data);
  }

  /**
   * Deserializes a SearchState hashtag generated by
   * {@link light.SearchRouter.searchStateToHash} throwing
   * errors if one of the following happens:
   * <ul>
   * <li>it can't correctly parse the given hashtag</li>
   * <li>if page is less then one.</li>
   * </ul>
   *
   * @param {string} hash Hashtag.
   * @return {Object} SearchState object.
   */
  SearchRouter.hashToSearchState = function(hash) {
    if (hash == '')
      return this.defaultSearchState;
    var data = dojo.queryToObject(hash);
    if (typeof data.page != 'string' || !data.page.match(RegexCommon.INTEGER)) {
      throw new Error('Page is not an integer');
    }
    data.page = parseInt(data.page);
    if (data.page <= 0) {
      throw new Error('Page is less then 1');
    }
    if (typeof data.query != 'string') {
      throw new Error('Query is not a string');
    }

    return data;
  }

  return SearchRouter;

});
